# Linux on the Watchguard XTM2 Platform (Richland)

# The RTL8366SR (probably RTL8366S) switch

- This turns out to be not that simple (at least for me)

- The Realtek PHY Switch is driven by a RTL8366SR chipset. The cambria does not use a switch, but there are other routers supported by OpenWrt/LEDE that feature this chipset. Looking at the vendor kernel 
boot log, a cutom module for the IXP4xx-eth driver seems to be used to init the PHYs correctly. Also it seems the first 3 ports, eth0 (WAN?), eth1 and eth2 are actually just IXP4xx PHYs ? The port 
eth3,eth4,eth5 are the only ports mapped to the realtek switch ? This may explain also the markings on the back of the router. (Ports 0-2 are 10/100 and Ports 3-5 are 10/100/1000.)


- Vendor Boot Log:
```
RTL8366 force link success! 
RTL8366 TMIIOneArm disable! 
RTL8366 TMIIOneArm success! 
ixp400: module license 'unspecified' taints kernel. 
richland: Starting Richland Board Driver V2.6 Built Jul 20 2011 13:02:07 
ixp400_eth: Starting IXP400 NPE Ethernet Driver V1.6 Built Jul 20 2011 13:01:27 
ixp400_eth: CPU clock speed (approx) = 665 MHz 
ixp400_eth: Init Chip realtek_split 3f7 
rtl8366s h/w revision=6027 
RTL8366 force link success! 
RTL8366 TMIIOneArm disable! 
RTL8366 TMIIOneArm success! 
ixp400_eth: Set Jumbo 
ixp400_eth: Set CPU Port 
ixp400_eth: ACL split 
ixp400_eth: Split up Realtek device 
ixp400_eth: Starting Queue Manager... 
ixp400_eth: ixCryptoAccInit() completed without error 
ixp400_eth: Setting PHY 16 Speed 100 Duplex FULL Autonegotiation ON 
ixp400_eth: Setting PHY 17 Speed 100 Duplex FULL Autonegotiation ON 
ixp400_eth: Setting PHY 18 Speed 100 Duplex FULL Autonegotiation ON 
ixp400_eth: Setting PHY 32 Speed 100 Duplex FULL Autonegotiation ON 
ixp400_eth: Setting PHY 33 Speed 100 Duplex FULL Autonegotiation ON 
ixp400_eth: Setting PHY 34 Speed 100 Duplex FULL Autonegotiation ON 
ixp400_eth: eth0 is using NPE C PHY 16 
ixp400_eth: eth1 is using NPE C PHY 17 
ixp400_eth: eth2 is using NPE C PHY 18 
ixp400_eth: eth3 is using NPE A PHY 32 
ixp400_eth: eth4 is using NPE A PHY 33 
ixp400_eth: eth5 is using NPE A PHY 34 
ixp400_eth: Register tx_done_disable_cb(1) 
ixp400_eth: eth3 Realtek Tag 9001 
ixp400_eth: Register tx_done_disable_cb(2) 
ixp400_eth: eth4 Realtek Tag 9002 
ixp400_eth: eth5 Realtek Tag 9004 
```

- Lame UnicodeArt to visualize the possibly layout:
```
    IXP400-ETH PHY        RTL8366S SWITCH (?)
┌──────┬──────┬──────┬──────┬──────┬──────┬────┐
│eth0  │eth1  │eth2  │eth3  │eth4  │eth4  │    │
│PHY16 │PHY17 │PHY18 │PHY32 │PHY33 │PHY34 │    │
│NPE-C │NPE-C │NPE-C │NPE-A │NPE-A │NPE-A │CPU │
│ixp4xx│ixp4xx│ixp4xx│9001  │9002  │9003  │    │
│10/100│10/100│10/100│1000  │1000  │1000  │    │
└──────┴──────┴──────┴──────┴──────┴──────┴────┘
 WAN?

```

- Porting some of the ixp435 NPE device code from the cambria-setup.c to the ixdp425-setup.c allows a network interfaces to come up. However the MAC addresses are not populated on boot and it does not 
work so far. 

```
static struct eth_plat_info kixrp435_npec_data = {
	.phy		= 16,
	.rxq		= 4,
	.txreadyq	= 21,
};

static struct eth_plat_info kixrp435_npea_data = {
	.phy		= 32,
	.rxq		= 2,
	.txreadyq	= 19,
};

static struct platform_device kixrp435_npec_device = {
	.name			= "ixp4xx_eth",
	.id			= IXP4XX_ETH_NPEC,
	.dev.platform_data	= &kixrp435_npec_data,
	.dev.coherent_dma_mask	= DMA_BIT_MASK(32),
};

static struct platform_device kixrp435_npea_device = {
	.name			= "ixp4xx_eth",
	.id			= IXP4XX_ETH_NPEA,
	.dev.platform_data	= &kixrp435_npea_data,
	.dev.coherent_dma_mask	= DMA_BIT_MASK(32),
};
```
- PHY 16 and 32 are picked up.

```
[    1.003656] eth0: MII PHY 16 on NPE-C
[    1.008475] eth1: MII PHY 32 on NPE-A
```
- Devices are created (note the missing MAC):

```
root@OpenWrt:/# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel master br-lan state UP qlen 100
    link/ether 00:11:22:33:44:55 brd ff:ff:ff:ff:ff:ff
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 100
    link/ether 00:11:22:33:44:56 brd ff:ff:ff:ff:ff:ff
4: br-lan: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 00:11:22:33:44:55 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.254/24 brd 192.168.1.255 scope global br-lan
       valid_lft forever preferred_lft forever
    inet6 fd0b:776e:f3c4::1/60 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::211:22ff:fe33:4455/64 scope link
       valid_lft forever preferred_lft forever
```
- This may be the wrong approach as the RTL8366 is not initialized and requires SMI init, but it is a start..I hope to get up the first 3 interfaces using basic IXP4xx NPE PHY.. well. I may be going down 
a rabbit hole..

# Next ? 

- Lets investigate the possibility that the first 3 ports are ixp4xx-eth PHYs and get these going first.


